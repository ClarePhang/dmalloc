/*
 * manual and automatic configuration flags
 *
 * Copyright 1995 by Gray Watson
 *
 * This file is part of the dmalloc package.
 *
 * Permission to use, copy, modify, and distribute this software for
 * any purpose and without fee is hereby granted, provided that the
 * above copyright notice and this permission notice appear in all
 * copies, and that the name of Gray Watson not be used in advertising
 * or publicity pertaining to distribution of the document or software
 * without specific, written prior permission.
 *
 * Gray Watson makes no representations about the suitability of the
 * software described herein for any purpose.  It is provided "as is"
 * without express or implied warranty.
 *
 * The author may be contacted at gray.watson@letters.com
 *
 * $Id: conf.h.in,v 1.40 1995/03/03 17:37:59 gray Exp $
 */

#ifndef __CONF_H__
#define __CONF_H__

/*
 ************************************************************************
 * MANUAL SETTINGS:
 ************************************************************************
 */

/*
 * should we include the RCS ids in the .c files and the installed
 * library?
 */
#define INCLUDE_RCS_IDS 1

/*
 * should we allow zero length allocations?  this will generate the
 * smallest possible allocation.  FYI: if fence post checking is
 * requested, the top and bottom of the fence post information will be
 * touching.
 */
#define ALLOW_ALLOC_ZERO_SIZE 0

/*
 * should we allow realloc of a NULL pointer?  if set to one, this
 * will call malloc when 0L is realloced.  this is useful when you are
 * extending an array in a loop and do not want to allocate it
 * specially the first time.
 */
#define ALLOW_REALLOC_NULL 1

/*
 * should we allow the free of a NULL pointer and if it happens,
 * should a message be generated to that effect?  I don't see how this
 * would be useful but some systems can, and I guess require this.  I
 * would recommend at least using the message to point out the
 * offenders because I would guess that this is not a portable feature
 * of most malloc libraries.
 */
#define ALLOW_FREE_NULL 0
#define ALLOW_FREE_NULL_MESSAGE 1

/*
 * should we use the ra-address macros in return.h.  These are system
 * specific macros designed to return the return-address for logging
 * callers (i.e. possible offenders) of malloc routines.  You should
 * only want to disable them if you are storing code which makes calls
 * to the dmalloc functions *from* the heap.  This is unlikely but
 * will confuse the library.  Please mail me if you have any questions
 * or if you indeed have this problem.
 */
#define USE_RET_ADDRESS 1

/*
 * the largest allowable allocations in bits.  This is only for
 * verification purposes.  Any allocation larger than this (in bits)
 * will generate a ERROR_TOO_BIG error (#15).  the default (24)
 * indicates that an allocation of more than 16mb (2^24) will generate
 * an error.
 */
#define LARGEST_BLOCK 24

/*
 * although I don't know why you would want to tune this since this is
 * pretty dependent on my general heap mechanisms, here are some
 * options to use general first, best, and worst fit algorithms.  if
 * you don't know what these are, then DON'T TOUCH.
 *
 * NOTES: they may go away in the future and/or be replaced by
 * debug-tokens.  I've tested all three and have not noticed any large
 * differences.  Also, they only apply for allocations > basic-block
 * (page) size.
 */
#define FIRST_FIT 1
#define BEST_FIT 0
#define WORST_FIT 0

/*
 * automatically call dmalloc_shutdown if on_exit or atexit is
 * available.  See below for whether configure found on_exit or atexit
 * calls.  If neither is available, take a look at atexit.c in the
 * contrib directory which may provide this useful functionality for
 * your system.
 */
#define AUTO_SHUTDOWN 1

/*
 * this macro is used to kill the current process and produce a
 * core-dump image.  Most Unix-like systems should use the kill line
 * (maybe with another signal from signal.h) although others may want
 * to substiture in the abort.
 *
 * WARNING: On some OS's, abort calls fclose() which may want to free
 * memory making the library go recursive.
 */
#define KILL_PROCESS()		(void)kill(0, SIGABRT)
/* #define KILL_PROCESS()		abort() */

/*
 * number of bytes to write at the top of allocations (if fence-post
 * checking is enabled).  A larger number means more memory space used
 * up but better protection against fence overruns.  See the manual
 * for more information.
 */
#define FENCE_TOP 4

/*
 * write the iteration count at the start of every log entry.  This is
 * handy when you are using the DMALLOC_START variable and want to
 * begin the tough debugging at a certain point.
 */
#define LOG_ITERATION_COUNT 1

/*
 ************************************************************************
 * CONFIGURE DEFINES: Should not need to be tuned by hand
 ************************************************************************
 */

/*
 * (char *)sbrk(const int incr) is the main heap-memory allocation
 * routine that most systems define/employ.  this extends the
 * program's data space by INCR number of bytes.  please mail me if
 * your system does not have this function.
 */
#define HAVE_SBRK 0

/*
 * does your heap grow up?  hopefully it does because there is not too
 * much support for growing-down heaps because I do not have a system
 * to test it on.  please mail me if configure generates a 0 for this
 * on your system.
 */
#define HEAP_GROWS_UP 1

/*
 * this is the basic block size in bits.  if possible, the configure
 * script will set this to be the value returned by the getpagesize()
 * function.  if not then some sort of best guess will be necessary.
 * 14 (meaning basic block size of 16k) will probably be good.
 *
 * NOTE: some sbrk functions round to the correct page-size.  If this
 * value is too low, the dmalloc library may think someone is using
 * sbrk behind its back and return a ERROR_ALLOC_NONLINEAR error
 * (#18).  No problems aside from a possible small increase in the
 * administration overhead should happen if this value is too high.
 */
#define BASIC_BLOCK 12

/*
 * the alignment value of all allocations in number of bytes for
 * loading admin information before an allocation.  if possible, the
 * configure script will set this to be the value returned by
 * sizeof(long) which in most systems is the register width.
 *
 * NOTE: the value will never be auto-configured to be less than 8
 * because some system (like sparc for instance) report the sizeof(long)
 * == 4 while the register size is 8 bytes.  certain memory needs to be of
 * the same base as the register size (stack frames, code, etc.).  any
 * ideas how I can determine the register size in a better (and portable)
 * fashion?
 *
 * NOTE: larger the number the more memory may be wasted by certain
 *       debugging settings like fence-post checking.
 */
#define ALLOCATION_ALIGNMENT 8

/*
 * LIBRARY DEFINES:
 */

/*
 * some systems have functions which can register routines to be
 * called by exit(3) (or when the program returns from main).  this
 * functionality allows the dmalloc_shutdown() routine to be called
 * automatically upon program completion so that the library can log
 * statistics.  use the AUTO_SHUTDOWN define above to disable this.
 * please send me mail if this functionality exists on your system but
 * in another name.
 *
 * NOTE: If neither is available, take a look at atexit.c in the
 * contrib directory which may provide this useful functionality for
 * your system.
 */
#define HAVE_ATEXIT 0
#define HAVE_ON_EXIT 0

/*
 * the dmalloc library provides its own versions of the following
 * functions, or knows how to work around their absence.
 */
#define HAVE_BCMP 0
#define HAVE_BCOPY 0
#define HAVE_MEMSET 0

#define HAVE_INDEX 0
#define HAVE_RINDEX 0

#define HAVE_STRCAT 0
#define HAVE_STRCMP 0
#define HAVE_STRCPY 0
#define HAVE_STRLEN 0
#define HAVE_STRTOK 0

/* place fillers */
#define HAVE_GETPID 0
#define HAVE_TIME 0

/* for argv files */
#define HAVE_STRDUP 0
#define HAVE_STRNCMP 0
#define HAVE_STRNCPY 0
#define HAVE_STRSTR 0


/*
 * the below functions are here to provide function argument checking
 * only.  the library only has stubs for these and does not use them
 * internally.
 */
#define HAVE_BZERO 0

#define HAVE_MEMCPY 0
#define HAVE_MEMCCPY 0
#define HAVE_MEMCHR 0
#define HAVE_MEMCMP 0

#define HAVE_STRCHR 0
#define HAVE_STRRCHR 0
#define HAVE_STRCASECMP 0
#define HAVE_STRNCASECMP 0
#define HAVE_STRSPN 0
#define HAVE_STRCSPN 0
#define HAVE_STRNCAT 0
#define HAVE_STRPBRK 0

#endif /* ! __CONF_H__ */
