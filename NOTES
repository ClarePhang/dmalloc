-------------------------------------------------------------------------------
$Id: NOTES,v 1.4 1992/09/04 21:22:41 gray Exp $
-------------------------------------------------------------------------------
TERMS:

bblock_adm	administration for a set of basic blocks
bblock		basic block containing 2 ^ BASIC_BLOCK bytes of info
dblock_adm	administration for a set of divided blocks
dblock		divided block containing some base 2 number of blocks smaller
		than a basic block.
chunk		some anonymous amount of memory
-------------------------------------------------------------------------------
IDEAS:

- maybe turn realloc into an intelligent beasty that looks on either side
	of existing chunk (if expanding) for free space and manages free-lists
	appropriately

- debug modes:
	- never reclaim memory, always extend the heap (don't use free lists)
	- crc all administration table information

- set a flag for the free-bblocks or user-allocated-bblocks that start the
	block or are continuations of an earlier block

	- won't have to reset all the pointers in a set of blocks
-------------------------------------------------------------------------------
ALGORITHM IDEAS:

- look in your free_list for first block.
	- if NULL then move up a bin and try to divide
	- continue until up X blocks then sbrk a new smaller block

- maybe try a finite number of free_bins above the one you want to limit
	fragmentation, test this thing
-------------------------------------------------------------------------------
WARNING:
	- watch for heaps growing up or down (all subtraction or other position
		dependent code must be changed to macros in heap.h) >,<,-,+,etc
	- watch for bounds checking assuming + or - code.
-------------------------------------------------------------------------------
NOTES:

- administration blocks are relocatable:
	- any administration blocks are relocatable in the heap which means
		that if we monitor the freeing of a block we have the
		opportunity to swap a higher admin block down which would mean
		we could possible locate as many admin blocks as possible in
		low memory making more contiguous usable areas

	- you have the freed blocks address

	- as you go through the admin blocks, until you get to the right entry,
		save a pointer to the highest (or lowest) one

	- when you find the free block, find out if it is lower (or higher)
		than the highest admin block and bcopy the admin block down and
		redo the pointers
-------------------------------------------------------------------------------
DBLOCK METHOD:

- have the bblock admin struct point to the dblock admin structure block which
	contains a number of dblock admin entries.
- have a global pointer that points to last free dblock admin structure entry
	and has a count of the number left in the block
- only allocate contiguous dblock admin slots so have some fragmentation
	- must have contiguous because bblocks do not have pointer to start of
		array
- maybe have a sorted free list of the number of free dblock admin structs.
	sorted in descending order
- you have the free pointer which gets you to the bblock where you can see if
	it is a dblock and if it is on the correct boundary.  Then you go to
	the dblock admin struct to get the file, line, size info.
- the bblock tells you of the number of bits in the chunk, etc.
- have some way to run through the dblock admin slot blocks to verify that
	crc's have not been overwritten.
-------------------------------------------------------------------------------
